<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WeatherBot AI - Live Global Feed</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100vh;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      position: relative;
      display: flex;
      flex-direction: column;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="20" cy="20" r="1" fill="white" opacity="0.05"/><circle cx="80" cy="40" r="1" fill="white" opacity="0.03"/><circle cx="40" cy="80" r="1" fill="white" opacity="0.07"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
      pointer-events: none;
      z-index: -1;
    }

    .live-ticker {
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(20px);
      color: white;
      height: 80px;
      overflow: hidden;
      position: relative;
      border-bottom: 2px solid rgba(255, 255, 255, 0.2);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      width: 100%;
      z-index: 10;
    }

    .ticker-wrapper {
      width: 100%;
      overflow: hidden;
      position: relative;
    }

    .ticker-content {
      display: flex;
      align-items: center;
      white-space: nowrap;
      will-change: transform;
    }

    .weather-item {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1.5rem;
      margin-right: 2rem;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      min-width: 220px;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }

    .weather-item:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(1.05);
    }

    .weather-item-icon {
      font-size: 1.3rem;
      opacity: 0.9;
      width: 20px;
      text-align: center;
    }

    .weather-item-info {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      flex: 1;
    }

    .weather-item-city {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .weather-item-desc {
      font-size: 0.75rem;
      opacity: 0.8;
      text-transform: capitalize;
    }

    .weather-item-temp {
      font-weight: 700;
      font-size: 1.1rem;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }



    .main-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      scroll-behavior: smooth;
      min-height: 0;
    }

    .chat-container::-webkit-scrollbar {
      width: 8px;
    }

    .chat-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    .chat-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }

    .chat-container::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    .message {
      max-width: 70%;
      padding: 1.25rem 1.5rem;
      border-radius: 20px;
      line-height: 1.6;
      font-size: 1rem;
      position: relative;
      animation: slideIn 0.4s ease-out;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .message.user {
      background: rgba(255, 255, 255, 0.95);
      color: #2c3e50;
      align-self: flex-end;
      border-bottom-right-radius: 8px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .message.bot {
      background: rgba(255, 255, 255, 0.9);
      color: #2c3e50;
      align-self: flex-start;
      border-bottom-left-radius: 8px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .message.loading {
      background: rgba(255, 255, 255, 0.8);
      color: #6c757d;
      align-self: flex-start;
      border-bottom-left-radius: 8px;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      backdrop-filter: blur(20px);
    }

    .typing-indicator {
      display: flex;
      gap: 4px;
    }

    .typing-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #6c757d;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }

    .weather-card {
      background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
      color: white;
      padding: 2rem;
      border-radius: 20px;
      box-shadow: 0 12px 40px rgba(116, 185, 255, 0.3);
      backdrop-filter: blur(20px);
      position: relative;
    }

    .learn-more-btn {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 0.75rem 1.25rem;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
      font-weight: 500;
      margin-top: 1rem;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      backdrop-filter: blur(10px);
    }

    .learn-more-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .learn-more-btn:active {
      transform: translateY(0);
    }

    .weather-info-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      border-radius: 20px;
      box-shadow: 0 12px 40px rgba(102, 126, 234, 0.3);
      backdrop-filter: blur(20px);
      margin-top: 1rem;
    }

    .weather-warning-card {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
      padding: 1.5rem;
      border-radius: 15px;
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
      backdrop-filter: blur(20px);
      margin-bottom: 1.5rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .weather-warning-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .weather-warning-icon {
      font-size: 1.5rem;
      color: #ffeb3b;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .weather-warning-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin: 0;
    }

    .weather-warning-text {
      margin: 0;
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .weather-info-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 1rem;
    }

    .weather-info-icon {
      font-size: 2rem;
      color: white;
    }

    .weather-info-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
    }

    .weather-info-sections {
      display: grid;
      gap: 1.5rem;
    }

    .weather-info-section {
      background: rgba(255, 255, 255, 0.15);
      padding: 1.25rem;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .weather-info-section h4 {
      margin: 0 0 0.75rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: white;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .weather-info-section p {
      margin: 0;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.9);
    }

    .weather-data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .weather-data-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .weather-data-label {
      font-size: 0.85rem;
      opacity: 0.8;
      margin-bottom: 0.5rem;
    }

    .weather-data-value {
      font-size: 1.2rem;
      font-weight: 600;
    }

    .precipitation-map {
      width: 100%;
      height: 200px;
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      margin-top: 1rem;
    }

    .forecast-timeline {
      display: flex;
      gap: 1rem;
      overflow-x: auto;
      padding: 1rem 0;
      margin-top: 1rem;
    }

    .forecast-item {
      min-width: 100px;
      background: rgba(255, 255, 255, 0.1);
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .forecast-time {
      font-size: 0.85rem;
      opacity: 0.8;
      margin-bottom: 0.5rem;
    }

    .forecast-icon {
      font-size: 1.5rem;
      margin: 0.5rem 0;
    }

    .forecast-temp {
      font-weight: 600;
    }

    .weather-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      gap: 2rem;
    }

    .weather-icon {
      font-size: 3rem;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .weather-temp {
      font-size: 2.5rem;
      font-weight: 700;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .weather-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid rgba(255, 255, 255, 0.3);
    }

    .weather-detail {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 1rem;
    }

    .weather-detail i {
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .welcome-message {
      text-align: center;
      color: rgba(255, 255, 255, 0.9);
      font-style: italic;
      opacity: 0.8;
      padding: 4rem 2rem;
      font-size: 1.1rem;
      line-height: 1.8;
    }

    .welcome-message i {
      font-size: 3rem;
      margin-bottom: 1.5rem;
      display: block;
      opacity: 0.7;
    }

    .input-container {
      padding: 2rem;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      flex-shrink: 0;
    }

    .input-form {
      display: flex;
      gap: 1rem;
      align-items: center;
      max-width: 1200px;
      margin: 0 auto;
    }

    .input-wrapper {
      flex: 1;
      position: relative;
    }

    .user-input {
      width: 100%;
      padding: 1.25rem 1.5rem;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      font-size: 1.1rem;
      font-family: inherit;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(20px);
      transition: all 0.3s ease;
      outline: none;
      color: #2c3e50;
    }

    .user-input:focus {
      border-color: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.95);
    }

    .user-input::placeholder {
      color: rgba(44, 62, 80, 0.6);
    }

    .submit-btn {
      padding: 1.25rem 1.5rem;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 60px;
      backdrop-filter: blur(20px);
      font-size: 1.1rem;
    }

    .submit-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .submit-btn:active {
      transform: translateY(0);
    }

    .submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .ticker-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
      padding: 0 2rem;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes typing {
      0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Force visibility */
    .live-ticker {
      opacity: 1 !important;
      visibility: visible !important;
      display: flex !important;
    }

    @media (max-width: 768px) {
      .live-ticker {
        height: 60px;
      }
      
      .weather-item {
        min-width: 180px;
        padding: 0.5rem 1rem;
        margin-right: 1rem;
      }
      
      .weather-item-city {
        font-size: 0.8rem;
      }
      
      .weather-item-temp {
        font-size: 1rem;
      }
      
      .weather-item-desc {
        font-size: 0.7rem;
      }
      
      .chat-container {
        padding: 1.5rem;
        gap: 1rem;
      }
      
      .message {
        max-width: 85%;
        padding: 1rem 1.25rem;
        font-size: 0.95rem;
      }
      
      .weather-card {
        padding: 1.5rem;
      }
      
      .weather-details {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      
      .weather-temp {
        font-size: 2rem;
      }
      
      .weather-icon {
        font-size: 2.5rem;
      }
      
      .input-container {
        padding: 1.5rem;
      }
      
      .input-form {
        gap: 0.75rem;
      }
      
      .user-input {
        padding: 1rem 1.25rem;
        font-size: 1rem;
      }
      
      .submit-btn {
        padding: 1rem 1.25rem;
        min-width: 50px;
      }
      
      .welcome-message {
        padding: 2rem 1rem;
        font-size: 1rem;
      }
      
      .welcome-message i {
        font-size: 2.5rem;
      }
    }

    @media (max-width: 480px) {
      .input-form {
        flex-direction: column;
        gap: 1rem;
      }
      
      .submit-btn {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="live-ticker" id="liveTicker">
    <div class="ticker-wrapper">
      <div class="ticker-loading">
        <i class="fas fa-globe-americas"></i>
        &nbsp; Initializing live weather feed...
      </div>
    </div>
  </div>
  
  <div class="main-container">
    <div class="chat-container" id="chatContainer">
      <div class="welcome-message">
        <i class="fas fa-robot"></i>
        Welcome to WeatherBot AI with live global weather feed!<br>
        I'm detecting your location to show local weather, then you can ask about anywhere:<br><br>
        <strong>"What's the weather in Tokyo?"</strong><br>
        <strong>"Is it raining in London?"</strong><br>
        <strong>"How's the weather in New York today?"</strong><br><br>
        <div style="padding: 0.75rem; background: rgba(116, 185, 255, 0.1); border-left: 3px solid #74b9ff; border-radius: 8px; font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-top: 1rem;">
          <i class="fas fa-shield-alt" style="margin-right: 0.5rem;"></i>
          <strong>Privacy:</strong> Location detection uses your IP address and data stays in your browser.
        </div>
      </div>
    </div>
    
    <div class="input-container">
      <form class="input-form" id="inputForm">
        <div class="input-wrapper">
          <input 
            type="text" 
            class="user-input" 
            id="userInput" 
            placeholder="Ask me about weather anywhere in the world..." 
            required 
            autocomplete="off"
          />
        </div>
        <button type="submit" class="submit-btn" id="submitBtn">
          <i class="fas fa-paper-plane"></i>
        </button>
      </form>
    </div>
  </div>

  <script>
    console.log('WeatherBot AI script starting...');
    
    const chatContainer = document.getElementById('chatContainer');
    const inputForm = document.getElementById('inputForm');
    const userInput = document.getElementById('userInput');
    const submitBtn = document.getElementById('submitBtn');
    const liveTicker = document.getElementById('liveTicker');

    const WEATHER_API_KEY = '57d1da3aa001e576f4e5fb9daca612c7';

    // Loading placeholders for weather ticker
    const loadingWeatherData = Array(12).fill().map((_, index) => ({
      city: 'Loading weather...',
      country: '--',
      temp: '--',
      description: 'fetching data',
      icon: 'fas fa-spinner fa-spin'
    }));

    let weatherQueue = [];
    let isTickerInitialized = false;
    let tickerScrollPosition = 0;
    let tickerAnimation = null;

    // Top cities for live weather feed
    const topCities = [
      'Tokyo', 'Delhi', 'Shanghai', 'São Paulo', 'Mumbai', 'Beijing', 'Cairo', 'Dhaka', 'Osaka', 'New York',
      'Karachi', 'Buenos Aires', 'Chongqing', 'Istanbul', 'Kolkata', 'Manila', 'Lagos', 'Rio de Janeiro', 'Tianjin', 'Kinshasa',
      'Guangzhou', 'Los Angeles', 'Moscow', 'Shenzhen', 'Lahore', 'Bangalore', 'Paris', 'Bogotá', 'Jakarta', 'Chennai',
      'Lima', 'Bangkok', 'Seoul', 'Nagoya', 'Hyderabad', 'London', 'Tehran', 'Chicago', 'Chengdu', 'Nanjing',
      'Wuhan', 'Ho Chi Minh City', 'Luanda', 'Ahmedabad', 'Kuala Lumpur', 'Xian', 'Hong Kong', 'Dongguan', 'Hangzhou', 'Foshan'
    ];

    // Weather icon mapping
    const getWeatherIcon = (description) => {
      const iconMap = {
        'clear sky': 'fas fa-sun',
        'few clouds': 'fas fa-cloud-sun',
        'scattered clouds': 'fas fa-cloud',
        'broken clouds': 'fas fa-cloud',
        'overcast clouds': 'fas fa-cloud',
        'shower rain': 'fas fa-cloud-rain',
        'rain': 'fas fa-cloud-rain',
        'light rain': 'fas fa-cloud-rain',
        'moderate rain': 'fas fa-cloud-rain',
        'heavy rain': 'fas fa-cloud-showers-heavy',
        'thunderstorm': 'fas fa-bolt',
        'snow': 'fas fa-snowflake',
        'mist': 'fas fa-smog',
        'fog': 'fas fa-smog'
      };
      return iconMap[description.toLowerCase()] || 'fas fa-cloud';
    };

    // Create weather item HTML
    function createWeatherItem(weatherData) {
      return `
        <div class="weather-item">
          <i class="${weatherData.icon} weather-item-icon"></i>
          <div class="weather-item-info">
            <div class="weather-item-city">${weatherData.city}, ${weatherData.country}</div>
            <div class="weather-item-desc">${weatherData.description}</div>
          </div>
          <div class="weather-item-temp">${weatherData.temp}°F <small style="opacity: 0.7; font-size: 0.8em;">(${Math.round((weatherData.temp - 32) * 5/9)}°C)</small></div>
        </div>
      `;
    }

    // Smooth ticker animation function
    function animateTicker() {
      const tickerContent = liveTicker.querySelector('.ticker-content');
      if (!tickerContent) return;

      // Move 1 pixel to the left every frame (smooth 60fps animation)
      tickerScrollPosition -= 1;
      
      // Get the width of half the content (since we have 2 copies)
      const contentWidth = tickerContent.scrollWidth / 2;
      
      // Reset position when first copy is completely off screen
      if (Math.abs(tickerScrollPosition) >= contentWidth) {
        tickerScrollPosition = 0;
      }
      
      // Apply the transform
      tickerContent.style.transform = `translateX(${tickerScrollPosition}px)`;
      
      // Continue animation
      tickerAnimation = requestAnimationFrame(animateTicker);
    }

    // Start the live ticker with immediate visibility
    function startLiveTicker() {
      console.log('Starting live ticker...');
      
      if (weatherQueue.length === 0) {
        console.warn('No weather data available for ticker');
        return;
      }

      console.log(`Creating ticker with ${weatherQueue.length} cities`);

      // Stop any existing animation
      if (tickerAnimation) {
        cancelAnimationFrame(tickerAnimation);
      }

      // Create ticker content - duplicate the content to create seamless loop
      const tickerItems = weatherQueue.map(createWeatherItem).join('');
      const tickerContent = `
        <div class="ticker-content">
          ${tickerItems}
          ${tickerItems}
        </div>
      `;

      liveTicker.innerHTML = tickerContent;
      
      // Reset scroll position and start animation
      tickerScrollPosition = 0;
      
      // Start the smooth animation after a brief delay to let DOM update
      setTimeout(() => {
        animateTicker();
      }, 100);
      
      console.log('Live ticker content updated and animation started');
    }

    // Initialize ticker with loading placeholders
    function initializeTicker() {
      console.log('Initializing ticker with loading placeholders...');
      weatherQueue = [...loadingWeatherData];
      startLiveTicker();
      isTickerInitialized = true;
      console.log('Ticker initialized with loading state');
      
      // Show loading indicator
      updateLoadingStatus('Loading live weather data from around the world...');
    }

    // Update loading status
    function updateLoadingStatus(message) {
      const welcomeMsg = chatContainer.querySelector('.welcome-message');
      if (welcomeMsg) {
        const loadingText = welcomeMsg.querySelector('.loading-status') || document.createElement('div');
        loadingText.className = 'loading-status';
        loadingText.style.cssText = 'margin-top: 1rem; color: rgba(255,255,255,0.7); font-size: 0.9rem; font-style: normal;';
        loadingText.innerHTML = `<i class="fas fa-sync fa-spin"></i> ${message}`;
        
        if (!welcomeMsg.querySelector('.loading-status')) {
          welcomeMsg.appendChild(loadingText);
        }
      }
    }

    // Clear loading status
    function clearLoadingStatus() {
      const loadingStatus = chatContainer.querySelector('.loading-status');
      if (loadingStatus) {
        loadingStatus.remove();
      }
    }

    // Fetch weather data for a city
    async function fetchCityWeather(city) {
      try {
        const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${WEATHER_API_KEY}&units=imperial`;
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch weather for ${city}`);
        }

        const data = await response.json();
        return {
          city: data.name,
          country: data.sys.country,
          temp: Math.round(data.main.temp),
          description: data.weather[0].description,
          icon: getWeatherIcon(data.weather[0].description)
        };
      } catch (error) {
        console.error(`Error fetching weather for ${city}:`, error);
        return null;
      }
    }

    // Load real weather data in parallel batches
    async function loadRealWeatherData() {
      console.log('Loading real weather data in parallel...');
      
      const shuffledCities = [...topCities].sort(() => Math.random() - 0.5);
      const batchSize = 6; // Larger batches for parallel processing
      let successCount = 0;
      
      for (let i = 0; i < Math.min(shuffledCities.length, 36); i += batchSize) {
        const batch = shuffledCities.slice(i, i + batchSize);
        
        try {
          // Process cities in parallel within each batch
          const batchPromises = batch.map(city => fetchCityWeather(city));
          const batchResults = await Promise.allSettled(batchPromises);
          
          // Process successful results
          batchResults.forEach((result, index) => {
            if (result.status === 'fulfilled' && result.value) {
              const weatherData = result.value;
              const replaceIndex = successCount % weatherQueue.length;
              weatherQueue[replaceIndex] = weatherData;
              successCount++;
              
              console.log(`✅ Loaded ${batch[index]} weather data (${successCount} cities loaded)`);
            } else {
              console.warn(`❌ Failed to fetch weather for ${batch[index]}`);
            }
          });
          
          // Update ticker display after each batch
          if (successCount > 0) {
            startLiveTicker();
            updateLoadingStatus(`Loading live weather data... ${successCount} cities loaded`);
          }
          
        } catch (error) {
          console.warn(`Batch error for cities ${batch.join(', ')}:`, error);
        }
        
        // Delay between batches to respect API limits
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
      console.log(`🎉 Live weather data loading complete! ${successCount} cities updated with real data`);
      
      // Final update to ticker
      if (successCount > 0) {
        startLiveTicker();
        updateLoadingStatus(`✅ Live weather data loaded! Showing real-time data from ${successCount} cities`);
        
        // Clear loading status after 5 seconds
        setTimeout(() => {
          clearLoadingStatus();
        }, 5000);
      }
    }

    // Refresh weather data periodically in parallel
    async function refreshWeatherData() {
      console.log('🔄 Refreshing weather data in parallel...');
      
      if (weatherQueue.length === 0) return;

      // Update 8 random cities every refresh
      const citiesToUpdate = [...weatherQueue]
        .filter(city => city.city !== 'Loading weather...') // Skip loading placeholders
        .sort(() => Math.random() - 0.5)
        .slice(0, 8);

      if (citiesToUpdate.length === 0) return;

      try {
        // Fetch all updates in parallel
        const updatePromises = citiesToUpdate.map(cityData => fetchCityWeather(cityData.city));
        const updateResults = await Promise.allSettled(updatePromises);
        
        let updateCount = 0;
        updateResults.forEach((result, index) => {
          if (result.status === 'fulfilled' && result.value) {
            const updatedWeather = result.value;
            const queueIndex = weatherQueue.findIndex(w => w.city === citiesToUpdate[index].city);
            if (queueIndex !== -1) {
              weatherQueue[queueIndex] = updatedWeather;
              updateCount++;
              console.log(`🔄 Refreshed ${updatedWeather.city} weather`);
            }
          } else {
            console.warn(`Failed to refresh ${citiesToUpdate[index].city}`);
          }
        });

        if (updateCount > 0) {
          startLiveTicker();
          console.log(`✅ Refreshed ${updateCount} cities in parallel`);
        }
      } catch (error) {
        console.warn('Error during parallel refresh:', error);
      }
    }

    // Standard chat functionality
    function addMessage(content, sender = 'user', isWeatherCard = false, isHtml = false) {
      const welcomeMsg = chatContainer.querySelector('.welcome-message');
      if (welcomeMsg) {
        welcomeMsg.remove();
      }

      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      if (isWeatherCard && typeof content === 'object') {
        messageDiv.innerHTML = createWeatherCard(content);
        messageDiv.style.padding = '0';
      } else if (isHtml) {
        messageDiv.innerHTML = content;
        messageDiv.style.padding = '0';
      } else {
        messageDiv.textContent = content;
      }
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return messageDiv;
    }

    function addLoadingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message loading';
      messageDiv.innerHTML = `
        <i class="fas fa-robot"></i>
        <span>Analyzing your request</span>
        <div class="typing-indicator">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      `;
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      return messageDiv;
    }

    function createWeatherCard(data) {
      const weatherIcon = getWeatherIcon(data.description);
      const cityName = data.city.split(',')[0].trim(); // Extract city name without country
      
      // Check for weather warnings
      const hasWarning = checkWeatherWarnings(data);
      const warningHtml = hasWarning ? `
        <div class="weather-warning-card">
          <div class="weather-warning-header">
            <i class="fas fa-exclamation-triangle weather-warning-icon"></i>
            <h4 class="weather-warning-title">${hasWarning.title}</h4>
          </div>
          <p class="weather-warning-text">${hasWarning.message}</p>
        </div>
      ` : '';

      return `
        ${warningHtml}
        <div class="weather-card">
          <div class="weather-header">
            <div>
              <h3 style="margin: 0; font-size: 1.4rem; font-weight: 600;">${data.city}</h3>
              <p style="margin: 0; opacity: 0.9; text-transform: capitalize; font-size: 1.1rem;">${data.description}</p>
            </div>
            <div style="text-align: right;">
              <i class="${weatherIcon} weather-icon"></i>
              <div class="weather-temp">${Math.round(data.temp)}°F<br><small style="opacity: 0.7; font-size: 0.7em;">(${Math.round((data.temp - 32) * 5/9)}°C)</small></div>
            </div>
          </div>
          <div class="weather-details">
            <div class="weather-detail">
              <i class="fas fa-thermometer-half"></i>
              <span>Feels like ${Math.round(data.feels_like)}°F <small style="opacity: 0.7;">(${Math.round((data.feels_like - 32) * 5/9)}°C)</small></span>
            </div>
            <div class="weather-detail">
              <i class="fas fa-tint"></i>
              <span>Humidity ${data.humidity}%</span>
            </div>
            <div class="weather-detail">
              <i class="fas fa-wind"></i>
              <span>Wind ${data.wind_speed} mph</span>
            </div>
            <div class="weather-detail">
              <i class="fas fa-eye"></i>
              <span>Visibility ${(data.visibility / 1000).toFixed(1)} km</span>
            </div>
          </div>
          <button class="learn-more-btn" onclick="showWeatherDetails('${cityName}', ${data.lat || 0}, ${data.lon || 0})">
            <i class="fas fa-chart-line"></i>
            Weather details & forecast
          </button>
        </div>
      `;
    }

    // Natural language processing and city extraction
    async function extractCityFromQuery(query) {
      const cityPatterns = [
        /(?:weather (?:in|for|at) )([a-zA-Z\s,.-]+?)(?:\?|$|,)/i,
        /(?:(?:what'?s|how'?s) (?:the )?weather (?:in|at|for) )([a-zA-Z\s,.-]+?)(?:\?|$|,)/i,
        /(?:is it (?:raining|snowing|sunny|cloudy) (?:in|at) )([a-zA-Z\s,.-]+?)(?:\?|$|,)/i,
        /(?:temperature (?:in|at|for) )([a-zA-Z\s,.-]+?)(?:\?|$|,)/i,
        /(?:forecast (?:for|in|at) )([a-zA-Z\s,.-]+?)(?:\?|$|,)/i,
        /(?:in )([a-zA-Z\s,.-]+?)(?:\?|$| today| tomorrow| now)/i,
        /(?:at )([a-zA-Z\s,.-]+?)(?:\?|$| today| tomorrow| now)/i,
        /(?:for )([a-zA-Z\s,.-]+?)(?:\?|$| today| tomorrow| now)/i,
        /(?:weather|temperature|forecast|raining|snowing|sunny|cloudy).+?([a-zA-Z\s,.-]+?)(?:\?|$)/i,
        /^([a-zA-Z\s,.-]+?)(?:\?|$)/i
      ];

      for (const pattern of cityPatterns) {
        const match = query.match(pattern);
        if (match && match[1]) {
          let city = match[1].trim();
          city = city.replace(/\b(weather|temperature|forecast|today|tomorrow|now|please|thanks?|thank you)\b/gi, '');
          city = city.replace(/\s+/g, ' ').trim();
          city = city.replace(/[,.-]+$/, '');
          
          if (city.length > 1 && city.length < 100) {
            return city;
          }
        }
      }

      const words = query.replace(/[^\w\s]/g, '').split(/\s+/);
      const stopWords = ['weather', 'what', 'is', 'the', 'in', 'at', 'for', 'how', 'today', 'tomorrow', 'now', 'like', 'there', 'it', 'raining', 'snowing', 'sunny', 'cloudy', 'temperature', 'forecast'];
      
      for (const word of words) {
        if (word.length > 2 && !stopWords.includes(word.toLowerCase())) {
          return word;
        }
      }

      return null;
    }

    // Weather data cache for learn more functionality
    const weatherDataCache = new Map();

    // IP-based location detection
    async function getCurrentLocationFromIP() {
      try {
        console.log('🌍 Detecting location from IP address...');
        
        // Try multiple IP geolocation services for better reliability
        const services = [
          {
            name: 'ipapi.co',
            url: 'https://ipapi.co/json/',
            parser: (data) => ({
              city: data.city,
              country: data.country_name,
              lat: data.latitude,
              lon: data.longitude,
              region: data.region
            })
          },
          {
            name: 'ipinfo.io',
            url: 'https://ipinfo.io/json',
            parser: (data) => {
              const [lat, lon] = (data.loc || '0,0').split(',');
              return {
                city: data.city,
                country: data.country,
                lat: parseFloat(lat),
                lon: parseFloat(lon),
                region: data.region
              };
            }
          },
          {
            name: 'ip-api.com',
            url: 'http://ip-api.com/json/',
            parser: (data) => ({
              city: data.city,
              country: data.country,
              lat: data.lat,
              lon: data.lon,
              region: data.regionName
            })
          }
        ];

        // Try services in order until one succeeds
        for (const service of services) {
          try {
            console.log(`Trying ${service.name}...`);
            const response = await fetch(service.url);
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            const location = service.parser(data);
            
            if (location.city && location.lat && location.lon) {
              console.log(`✅ Location detected via ${service.name}:`, location);
              return location;
            } else {
              throw new Error('Incomplete location data');
            }
          } catch (error) {
            console.warn(`❌ ${service.name} failed:`, error.message);
            continue;
          }
        }
        
        throw new Error('All geolocation services failed');
        
      } catch (error) {
        console.error('Failed to detect location:', error);
        return null;
      }
    }

    // Get weather for detected location
    async function getLocationWeather(location) {
      try {
        // Try by coordinates first (most accurate)
        if (location.lat && location.lon) {
          const coordUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${location.lat}&lon=${location.lon}&appid=${WEATHER_API_KEY}&units=imperial`;
          
          try {
            const response = await fetch(coordUrl);
            if (response.ok) {
              const data = await response.json();
              return {
                city: data.name + (data.sys.country ? `, ${data.sys.country}` : ''),
                temp: data.main.temp,
                feels_like: data.main.feels_like,
                description: data.weather[0].description,
                humidity: data.main.humidity,
                wind_speed: data.wind.speed,
                visibility: data.visibility || 10000,
                lat: data.coord.lat,
                lon: data.coord.lon,
                detectedLocation: true,
                originalLocation: location
              };
            }
          } catch (coordError) {
            console.warn('Coordinate-based weather failed, trying city name...');
          }
        }
        
        // Fallback to city name
        if (location.city) {
          return await getWeatherData(location.city);
        }
        
        throw new Error('No usable location data');
        
      } catch (error) {
        console.error('Failed to get location weather:', error);
        throw error;
      }
    }

    // Initialize location-based weather on page load
    async function initializeLocationWeather() {
      try {
        const location = await getCurrentLocationFromIP();
        
        if (!location) {
          console.log('Could not detect location, skipping auto-weather');
          return;
        }
        
        // Show loading message
        const loadingMsg = addLoadingMessage();
        loadingMsg.innerHTML = `
          <i class="fas fa-map-marker-alt"></i>
          <span>Loading weather for your location (${location.city || 'detected area'})...</span>
          <div class="typing-indicator">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
          </div>
        `;
        
        // Get weather for the detected location
        const weatherData = await getLocationWeather(location);
        loadingMsg.remove();
        
        // Show location detection message
        const locationMessage = location.city && location.country ? 
          `I detected you're in ${location.city}, ${location.country}. Here's your local weather:` :
          `I detected your approximate location. Here's your local weather:`;
        
        addMessage(locationMessage, 'bot');
        addMessage(weatherData, 'bot', true);
        
        console.log('✅ Successfully loaded location-based weather');
        
      } catch (error) {
        console.error('Location weather initialization failed:', error);
        
        // Show helpful message if location detection fails
        const fallbackMessage = `I couldn't detect your location, but I can still help! Try asking about weather in popular cities like New York, London, Tokyo, or Paris.`;
        addMessage(fallbackMessage, 'bot');
        
        // Update welcome message to remove location detection reference
        const welcomeMsg = chatContainer.querySelector('.welcome-message');
        if (welcomeMsg) {
          const loadingStatus = welcomeMsg.querySelector('.loading-status');
          if (loadingStatus) {
            loadingStatus.remove();
          }
        }
      }
    }

    // Enhanced typo correction database
    const cityCorrections = {
      // Major cities - common typos
      'tokio': 'tokyo', 'tokoy': 'tokyo', 'tokoyo': 'tokyo', 'toko': 'tokyo', 'toyko': 'tokyo',
      'londn': 'london', 'lundon': 'london', 'londen': 'london', 'londan': 'london', 'londong': 'london',
      'parise': 'paris', 'pariss': 'paris', 'paries': 'paris', 'pariz': 'paris', 'parris': 'paris',
      'newyork': 'new york', 'ny': 'new york', 'nyc': 'new york', 'newyourk': 'new york', 'new yourk': 'new york',
      'berln': 'berlin', 'belin': 'berlin', 'birlin': 'berlin', 'barlin': 'berlin',
      'sydny': 'sydney', 'sidny': 'sydney', 'sydey': 'sydney', 'syney': 'sydney',
      
      // Asian cities
      'bejing': 'beijing', 'peking': 'beijing', 'biejing': 'beijing', 'beijng': 'beijing',
      'shangai': 'shanghai', 'shanghia': 'shanghai', 'shanhai': 'shanghai',
      'mumbay': 'mumbai', 'bombay': 'mumbai', 'mumbai': 'mumbai', 'mumbia': 'mumbai',
      'deli': 'delhi', 'dehli': 'delhi', 'delhy': 'delhi', 'new delhi': 'delhi',
      'singapur': 'singapore', 'singapor': 'singapore', 'singapure': 'singapore',
      'bangkog': 'bangkok', 'bankok': 'bangkok', 'bangkong': 'bangkok',
      'seol': 'seoul', 'soul': 'seoul', 'seul': 'seoul',
      
      // US cities
      'losangeles': 'los angeles', 'la': 'los angeles', 'los angelos': 'los angeles', 'los angelis': 'los angeles',
      'sanfrancisco': 'san francisco', 'sf': 'san francisco', 'san fransisco': 'san francisco', 'san franciso': 'san francisco',
      'chicgo': 'chicago', 'shicago': 'chicago', 'chicgao': 'chicago', 'chigago': 'chicago',
      'miamy': 'miami', 'maimi': 'miami', 'maiami': 'miami', 'mimai': 'miami',
      'las vegas': 'las vegas', 'lasvegas': 'las vegas', 'vegas': 'las vegas',
      'seatle': 'seattle', 'seatel': 'seattle', 'seattel': 'seattle',
      'filadelfia': 'philadelphia', 'phyladelphia': 'philadelphia', 'philadelfia': 'philadelphia',
      'huston': 'houston', 'housten': 'houston', 'hoston': 'houston',
      'phenix': 'phoenix', 'pheonix': 'phoenix', 'fenix': 'phoenix',
      
      // European cities
      'amsterdan': 'amsterdam', 'amsterdaam': 'amsterdam', 'amesterdam': 'amsterdam',
      'barcelon': 'barcelona', 'barselona': 'barcelona', 'barcalona': 'barcelona',
      'madris': 'madrid', 'madrit': 'madrid', 'madrid': 'madrid',
      'millan': 'milan', 'milano': 'milan', 'miln': 'milan',
      'vena': 'vienna', 'viena': 'vienna', 'wien': 'vienna',
      'praga': 'prague', 'prag': 'prague', 'praha': 'prague',
      'budapesht': 'budapest', 'budapesh': 'budapest', 'budepest': 'budapest',
      'warsawa': 'warsaw', 'warszawa': 'warsaw', 'varsava': 'warsaw',
      'stokholm': 'stockholm', 'stockholm': 'stockholm', 'stokgolm': 'stockholm',
      'kopenhagen': 'copenhagen', 'kobenhavn': 'copenhagen', 'copenhagan': 'copenhagen',
      'helsinky': 'helsinki', 'helsenki': 'helsinki', 'helsingi': 'helsinki',
      'osló': 'oslo', 'oslow': 'oslo', 'osloa': 'oslo',
      'zurich': 'zurich', 'zürich': 'zurich', 'zurih': 'zurich',
      'geneve': 'geneva', 'genova': 'geneva', 'jeneva': 'geneva',
      
      // Middle East & Africa
      'dubay': 'dubai', 'dubái': 'dubai', 'dubi': 'dubai', 'dubaï': 'dubai',
      'kahira': 'cairo', 'kairo': 'cairo', 'qahirah': 'cairo',
      'istambul': 'istanbul', 'istanbul': 'istanbul', 'stambul': 'istanbul',
      'tel aviv': 'tel aviv', 'telaviv': 'tel aviv', 'tel-aviv': 'tel aviv',
      'riyadh': 'riyadh', 'riad': 'riyadh', 'ryad': 'riyadh',
      'casablanca': 'casablanca', 'kazablanka': 'casablanca', 'casblanca': 'casablanca',
      
      // South America
      'sao paulo': 'são paulo', 'saopaulo': 'são paulo', 'san paulo': 'são paulo',
      'rio de janeiro': 'rio de janeiro', 'rio': 'rio de janeiro', 'riodejaneiro': 'rio de janeiro',
      'buenos aires': 'buenos aires', 'buenosaires': 'buenos aires', 'b aires': 'buenos aires',
      'bogota': 'bogotá', 'bogotá': 'bogotá', 'bogotta': 'bogotá',
      'lima': 'lima', 'lyma': 'lima', 'limas': 'lima',
      
      // Australia & Oceania
      'melbourn': 'melbourne', 'melborne': 'melbourne', 'melbrun': 'melbourne',
      'perth': 'perth', 'pert': 'perth', 'pirth': 'perth',
      'brisban': 'brisbane', 'brisbaine': 'brisbane', 'brisben': 'brisbane',
      'adelaid': 'adelaide', 'adelade': 'adelaide', 'adelayde': 'adelaide',
      'auckland': 'auckland', 'aukland': 'auckland', 'oklend': 'auckland',
      
      // Canada
      'toronto': 'toronto', 'toranto': 'toronto', 'tronto': 'toronto',
      'vancouver': 'vancouver', 'vancuver': 'vancouver', 'vancourver': 'vancouver',
      'montreal': 'montreal', 'monreal': 'montreal', 'montrial': 'montreal',
      'ottawa': 'ottawa', 'otawa': 'ottawa', 'ottava': 'ottawa',
      'calgary': 'calgary', 'calgery': 'calgary', 'calgari': 'calgary',
      
      // Russia & Eastern Europe
      'moscow': 'moscow', 'moskva': 'moscow', 'moskow': 'moscow', 'moskov': 'moscow',
      'st petersburg': 'saint petersburg', 'stpetersburg': 'saint petersburg', 'petersburg': 'saint petersburg',
      'kiev': 'kyiv', 'kiyv': 'kyiv', 'kiyev': 'kyiv', 'kijev': 'kyiv',
      'minsk': 'minsk', 'mynsk': 'minsk', 'mensk': 'minsk'
    };

    // Known major cities for fuzzy matching
    const majorCities = [
      'tokyo', 'delhi', 'shanghai', 'dhaka', 'são paulo', 'cairo', 'mexico city', 'beijing', 'mumbai',
      'osaka', 'chongqing', 'karachi', 'istanbul', 'kinshasa', 'lagos', 'buenos aires', 'kolkata',
      'manila', 'tianjin', 'guangzhou', 'rio de janeiro', 'lahore', 'bangalore', 'moscow', 'shenzhen',
      'nagoya', 'london', 'lima', 'bangkok', 'seoul', 'jakarta', 'tokyo', 'chennai', 'bogotá',
      'ho chi minh city', 'hyderabad', 'paris', 'chicago', 'tehran', 'kuala lumpur', 'baghdad',
      'new york', 'los angeles', 'berlin', 'madrid', 'kiev', 'rome', 'paris', 'hamburg', 'warsaw',
      'budapest', 'barcelona', 'munich', 'milan', 'prague', 'sofia', 'vienna', 'amsterdam',
      'brussels', 'stockholm', 'copenhagen', 'oslo', 'helsinki', 'dublin', 'lisbon', 'athens',
      'bucharest', 'zurich', 'geneva', 'singapore', 'sydney', 'melbourne', 'perth', 'brisbane',
      'adelaide', 'auckland', 'wellington', 'toronto', 'montreal', 'vancouver', 'ottawa', 'calgary',
      'dubai', 'doha', 'kuwait city', 'riyadh', 'muscat', 'manama', 'tel aviv', 'jerusalem',
      'beirut', 'damascus', 'amman', 'casablanca', 'algiers', 'tunis', 'rabat', 'alexandria',
      'johannesburg', 'cape town', 'durban', 'nairobi', 'addis ababa', 'accra', 'dakar', 'abidjan'
    ];

    // NLP-inspired typo detection system
    
    // Phonetic encoding (Soundex-like algorithm for cities)
    function phoneticEncode(str) {
      const word = str.toLowerCase().replace(/[^a-z]/g, '');
      if (!word) return '';
      
      // Character mappings for similar sounds
      const soundMap = {
        'c': 's', 'k': 's', 'q': 's',
        'f': 'v', 'ph': 'v',
        'j': 'g', 'gh': 'g',
        'z': 's', 'x': 's',
        'y': 'i', 'w': 'v'
      };
      
      let phonetic = word[0]; // Keep first letter
      
      for (let i = 1; i < word.length; i++) {
        let char = word[i];
        let prev = word[i-1];
        
        // Apply sound mappings
        if (soundMap[char]) char = soundMap[char];
        
        // Remove consecutive duplicates
        if (char !== phonetic[phonetic.length - 1]) {
          phonetic += char;
        }
      }
      
      // Remove vowels except first character
      if (phonetic.length > 1) {
        phonetic = phonetic[0] + phonetic.slice(1).replace(/[aeiou]/g, '');
      }
      
      return phonetic;
    }

    // N-gram similarity for character-level patterns
    function ngramSimilarity(str1, str2, n = 2) {
      const getNgrams = (s, n) => {
        const ngrams = [];
        const padded = ' '.repeat(n-1) + s + ' '.repeat(n-1);
        for (let i = 0; i <= padded.length - n; i++) {
          ngrams.push(padded.slice(i, i + n));
        }
        return ngrams;
      };
      
      const ngrams1 = new Set(getNgrams(str1.toLowerCase(), n));
      const ngrams2 = new Set(getNgrams(str2.toLowerCase(), n));
      
      const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
      const union = new Set([...ngrams1, ...ngrams2]);
      
      return union.size === 0 ? 0 : intersection.size / union.size;
    }

    // Character-level embedding similarity
    function characterEmbeddingSimilarity(str1, str2) {
      // Create character frequency vectors
      const getCharVector = (s) => {
        const vector = {};
        const normalized = s.toLowerCase().replace(/[^a-z]/g, '');
        for (const char of normalized) {
          vector[char] = (vector[char] || 0) + 1;
        }
        return vector;
      };
      
      const vec1 = getCharVector(str1);
      const vec2 = getCharVector(str2);
      
      // Calculate cosine similarity
      const allChars = new Set([...Object.keys(vec1), ...Object.keys(vec2)]);
      let dotProduct = 0;
      let norm1 = 0;
      let norm2 = 0;
      
      for (const char of allChars) {
        const val1 = vec1[char] || 0;
        const val2 = vec2[char] || 0;
        dotProduct += val1 * val2;
        norm1 += val1 * val1;
        norm2 += val2 * val2;
      }
      
      if (norm1 === 0 || norm2 === 0) return 0;
      return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }

    // Keyboard layout distance (QWERTY-based)
    function keyboardDistance(char1, char2) {
      const keyboard = {
        'q': [0, 0], 'w': [1, 0], 'e': [2, 0], 'r': [3, 0], 't': [4, 0], 'y': [5, 0], 'u': [6, 0], 'i': [7, 0], 'o': [8, 0], 'p': [9, 0],
        'a': [0, 1], 's': [1, 1], 'd': [2, 1], 'f': [3, 1], 'g': [4, 1], 'h': [5, 1], 'j': [6, 1], 'k': [7, 1], 'l': [8, 1],
        'z': [0, 2], 'x': [1, 2], 'c': [2, 2], 'v': [3, 2], 'b': [4, 2], 'n': [5, 2], 'm': [6, 2]
      };
      
      const pos1 = keyboard[char1.toLowerCase()];
      const pos2 = keyboard[char2.toLowerCase()];
      
      if (!pos1 || !pos2) return 10; // High distance for non-keyboard chars
      
      return Math.sqrt(Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2));
    }

    // Enhanced Levenshtein with keyboard-aware weights
    function weightedLevenshtein(str1, str2) {
      const matrix = [];
      const len1 = str1.length;
      const len2 = str2.length;

      // Initialize matrix
      for (let i = 0; i <= len2; i++) {
        matrix[i] = [i];
      }
      for (let j = 0; j <= len1; j++) {
        matrix[0][j] = j;
      }

      // Fill matrix with weighted costs
      for (let i = 1; i <= len2; i++) {
        for (let j = 1; j <= len1; j++) {
          const char1 = str1.charAt(j - 1);
          const char2 = str2.charAt(i - 1);
          
          if (char1 === char2) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            // Weight substitution cost based on keyboard distance
            const substitutionCost = Math.min(2.0, 0.5 + keyboardDistance(char1, char2) * 0.3);
            
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + substitutionCost, // substitution
              matrix[i][j - 1] + 1,                    // insertion
              matrix[i - 1][j] + 1                     // deletion
            );
          }
        }
      }
      
      return matrix[len2][len1];
    }

    // NLP-inspired similarity score combining multiple signals
    function nlpSimilarityScore(input, candidate) {
      const inputLower = input.toLowerCase().trim();
      const candidateLower = candidate.toLowerCase().trim();
      
      // Early exact match
      if (inputLower === candidateLower) return 1.0;
      
      // Length difference penalty
      const lengthRatio = Math.min(inputLower.length, candidateLower.length) / 
                         Math.max(inputLower.length, candidateLower.length);
      if (lengthRatio < 0.5) return 0; // Too different in length
      
      // Multiple similarity signals
      const phoneticSim = phoneticEncode(inputLower) === phoneticEncode(candidateLower) ? 0.3 : 0;
      const ngramSim = ngramSimilarity(inputLower, candidateLower, 2) * 0.25;
      const charEmbedSim = characterEmbeddingSimilarity(inputLower, candidateLower) * 0.2;
      
      // Weighted edit distance (lower is better, normalize to 0-1)
      const maxLen = Math.max(inputLower.length, candidateLower.length);
      const editDistance = weightedLevenshtein(inputLower, candidateLower);
      const editSim = Math.max(0, (maxLen - editDistance) / maxLen) * 0.25;
      
      // Bonus for substring matches
      const substringBonus = (inputLower.includes(candidateLower) || candidateLower.includes(inputLower)) ? 0.1 : 0;
      
      const totalScore = phoneticSim + ngramSim + charEmbedSim + editSim + substringBonus;
      return Math.min(1.0, totalScore);
    }

    // NLP-enhanced city spelling correction
    function correctCitySpelling(city) {
      const normalizedCity = city.toLowerCase().trim();
      
      // First check exact matches in corrections database
      if (cityCorrections[normalizedCity]) {
        return cityCorrections[normalizedCity];
      }
      
      // If city name is too short or too long, don't fuzzy match
      if (normalizedCity.length < 2 || normalizedCity.length > 35) {
        return city;
      }
      
      // NLP-based matching with major cities
      let bestMatch = null;
      let bestScore = 0.6; // Minimum confidence threshold
      let matchDetails = null;
      
      for (const majorCity of majorCities) {
        const score = nlpSimilarityScore(normalizedCity, majorCity);
        
        if (score > bestScore) {
          bestMatch = majorCity;
          bestScore = score;
          matchDetails = {
            score: score,
            phonetic: phoneticEncode(normalizedCity) === phoneticEncode(majorCity),
            ngram: ngramSimilarity(normalizedCity, majorCity, 2),
            embedding: characterEmbeddingSimilarity(normalizedCity, majorCity)
          };
        }
      }
      
      // Also check corrections database with NLP scoring
      for (const [typo, correction] of Object.entries(cityCorrections)) {
        const score = nlpSimilarityScore(normalizedCity, typo);
        
        if (score > bestScore) {
          bestMatch = correction;
          bestScore = score;
          matchDetails = {
            score: score,
            phonetic: phoneticEncode(normalizedCity) === phoneticEncode(typo),
            ngram: ngramSimilarity(normalizedCity, typo, 2),
            embedding: characterEmbeddingSimilarity(normalizedCity, typo),
            exactCorrection: true
          };
        }
      }
      
      // Enhanced substring and partial matching
      for (const majorCity of majorCities) {
        // Check if input is a significant substring of a city name
        if (majorCity.includes(normalizedCity) && normalizedCity.length >= 4) {
          const partialScore = 0.7 + (normalizedCity.length / majorCity.length) * 0.2;
          if (partialScore > bestScore) {
            bestMatch = majorCity;
            bestScore = partialScore;
            matchDetails = { score: partialScore, partial: true };
          }
        }
        
        // Check if city is a substring of input (with extra characters)
        if (normalizedCity.includes(majorCity) && majorCity.length >= 4) {
          const partialScore = 0.65 + (majorCity.length / normalizedCity.length) * 0.2;
          if (partialScore > bestScore) {
            bestMatch = majorCity;
            bestScore = partialScore;
            matchDetails = { score: partialScore, contains: true };
          }
        }
      }
      
      // Return best match if found with sufficient confidence
      return bestMatch || city;
    }

    // Function to check if correction was applied with detailed analysis
    function getCityCorrection(originalCity) {
      const originalNormalized = originalCity.toLowerCase().trim();
      const corrected = correctCitySpelling(originalCity);
      const correctedNormalized = corrected.toLowerCase();
      
      const wasCorreted = correctedNormalized !== originalNormalized;
      
      if (!wasCorreted) {
        return {
          corrected: corrected,
          wasCorreted: false,
          confidence: 1.0,
          method: 'exact'
        };
      }
      
      // Calculate confidence based on NLP similarity
      const similarity = nlpSimilarityScore(originalNormalized, correctedNormalized);
      
      // Determine correction method for better user feedback
      let method = 'nlp_fuzzy';
      let confidence = similarity;
      
      // Check if it was an exact correction from database
      if (cityCorrections[originalNormalized] === correctedNormalized) {
        method = 'exact_correction';
        confidence = 0.95;
      }
      // Check if it's a phonetic match
      else if (phoneticEncode(originalNormalized) === phoneticEncode(correctedNormalized)) {
        method = 'phonetic';
        confidence = Math.max(0.85, similarity);
      }
      // Check if it's a partial match
      else if (originalNormalized.includes(correctedNormalized) || correctedNormalized.includes(originalNormalized)) {
        method = 'partial';
        confidence = Math.max(0.75, similarity);
      }
      
      return {
        corrected: corrected,
        wasCorreted: true,
        confidence: confidence,
        method: method,
        similarity: similarity,
        phoneticMatch: phoneticEncode(originalNormalized) === phoneticEncode(correctedNormalized),
        ngramSimilarity: ngramSimilarity(originalNormalized, correctedNormalized, 2),
        embeddingSimilarity: characterEmbeddingSimilarity(originalNormalized, correctedNormalized)
      };
    }

    async function getWeatherData(city) {
      const correction = getCityCorrection(city);
      const correctedCity = correction.corrected;
      
      const tryCity = async (cityName) => {
        const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(cityName)}&appid=${WEATHER_API_KEY}&units=imperial`;
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Not found: ${cityName}`);
        }

        const data = await response.json();
        return {
          city: data.name + (data.sys.country ? `, ${data.sys.country}` : ''),
          temp: data.main.temp,
          feels_like: data.main.feels_like,
          description: data.weather[0].description,
          humidity: data.main.humidity,
          wind_speed: data.wind.speed,
          visibility: data.visibility || 10000,
          lat: data.coord.lat,
          lon: data.coord.lon,
          corrected: correction.wasCorreted ? correctedCity : null,
          confidence: correction.confidence
        };
      };

      // Try multiple variations for better success rate
      const variations = [city];
      
      if (correction.wasCorreted) {
        variations.push(correctedCity);
      }
      
      // Add some common variations
      const cleanCity = city.replace(/[^a-zA-Z\s]/g, '').trim();
      if (cleanCity !== city && !variations.includes(cleanCity)) {
        variations.push(cleanCity);
      }
      
      // Try title case version
      const titleCase = city.split(' ').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      ).join(' ');
      if (!variations.includes(titleCase)) {
        variations.push(titleCase);
      }

      // Try each variation
      let lastError = null;
      for (const variation of variations) {
        try {
          const result = await tryCity(variation);
          
          // If we used a corrected version, update the result
          if (variation !== city && correction.wasCorreted) {
            result.corrected = correctedCity;
            result.originalInput = city;
          }
          
          return result;
        } catch (error) {
          lastError = error;
          console.log(`Failed to find weather for "${variation}", trying next variation...`);
        }
      }
      
      // If all variations failed, provide helpful error message
      const suggestion = correction.wasCorreted ? 
        ` Did you mean "${correctedCity}"?` : 
        ' Please check the spelling and try again.';
      
      throw new Error(`I couldn't find weather information for "${city}".${suggestion}`);
    }

    // Get 5-day forecast data
    async function getForecastData(city) {
      try {
        const url = `https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(city)}&appid=${WEATHER_API_KEY}&units=imperial`;
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error('Forecast data unavailable');
        }
        
        const data = await response.json();
        const dailyForecasts = [];
        
        // Group by day and take noon forecasts
        const grouped = {};
        data.list.forEach(item => {
          const date = new Date(item.dt * 1000);
          const dateKey = date.toISOString().split('T')[0];
          
          if (!grouped[dateKey] || date.getHours() === 12) {
            grouped[dateKey] = item;
          }
        });
        
        // Convert to daily format
        Object.keys(grouped).slice(0, 5).forEach(dateKey => {
          const item = grouped[dateKey];
          const date = new Date(item.dt * 1000);
          
          dailyForecasts.push({
            date: date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
            temp_max: item.main.temp_max,
            temp_min: item.main.temp_min,
            description: item.weather[0].description,
            humidity: item.main.humidity,
            wind_speed: item.wind.speed
          });
        });
        
        return dailyForecasts;
      } catch (error) {
        // Return mock data if API fails (Fahrenheit)
        return [
          { date: 'Today', temp_max: 72, temp_min: 59, description: 'partly cloudy' },
          { date: 'Tomorrow', temp_max: 75, temp_min: 61, description: 'sunny' },
          { date: 'Wed', temp_max: 68, temp_min: 54, description: 'light rain' },
          { date: 'Thu', temp_max: 77, temp_min: 64, description: 'clear sky' },
          { date: 'Fri', temp_max: 73, temp_min: 63, description: 'few clouds' }
        ];
      }
    }

    // Get historical weather data (simulated for now)
    async function getHistoricalWeatherData(city) {
      try {
        // In a real implementation, you'd use a historical weather API
        // For now, we'll generate realistic historical data based on current conditions
        
        // Simulate API call delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Generate realistic historical data (Fahrenheit)
        const baseTemp = 68; // Base temperature (68°F = 20°C)
        const variation = 9; // Temperature variation (9°F = 5°C)
        
        const historicalData = {
          avgHigh: Math.round(baseTemp + variation + (Math.random() * 7 - 3.5)), // Random ±3.5°F
          avgLow: Math.round(baseTemp - variation + (Math.random() * 7 - 3.5)), // Random ±3.5°F
          totalRain: Math.round(Math.random() * 15), // 0-15mm rainfall
          avgHumidity: Math.round(60 + (Math.random() * 20 - 10)) // 50-70% humidity
        };
        
        return historicalData;
      } catch (error) {
        return {
          avgHigh: 72,  // 72°F = 22°C
          avgLow: 59,   // 59°F = 15°C
          totalRain: 5,
          avgHumidity: 65
        };
      }
    }

    // Generate weather insights
    function generateWeatherInsights(cityName, forecastData, historicalData) {
      const insights = [];
      
      // Temperature trend analysis (Fahrenheit)
      if (forecastData.length >= 2) {
        const tempTrend = forecastData[1].temp_max - forecastData[0].temp_max;
        if (tempTrend > 5) {  // 5°F change is significant
          insights.push("📈 Temperatures are expected to rise significantly over the next few days.");
        } else if (tempTrend < -5) {  // 5°F change is significant
          insights.push("📉 A cooling trend is expected in the coming days.");
        } else {
          insights.push("🌡️ Temperatures are expected to remain relatively stable.");
        }
      }
      
      // Precipitation forecast
      const rainyDays = forecastData.filter(day => 
        day.description.includes('rain') || day.description.includes('shower') || day.description.includes('drizzle')
      ).length;
      
      if (rainyDays >= 3) {
        insights.push("☔ Expect frequent rain over the next few days. Consider carrying an umbrella.");
      } else if (rainyDays >= 1) {
        insights.push("🌦️ Some rain is expected this week. Plan outdoor activities accordingly.");
      } else {
        insights.push("☀️ Mostly dry conditions expected - great for outdoor activities!");
      }
      
      // Historical comparison (Fahrenheit)
      const currentTemp = forecastData[0]?.temp_max || 68;  // Default 68°F
      if (currentTemp > historicalData.avgHigh + 9) {  // 9°F = 5°C difference
        insights.push("🔥 Current temperatures are significantly above the recent average.");
      } else if (currentTemp < historicalData.avgLow - 9) {  // 9°F = 5°C difference
        insights.push("❄️ Temperatures are notably cooler than usual for this time.");
      }
      
      // Humidity insights
      if (historicalData.avgHumidity > 80) {
        insights.push("💧 High humidity levels may make it feel warmer than the actual temperature.");
      } else if (historicalData.avgHumidity < 40) {
        insights.push("🏜️ Low humidity conditions - stay hydrated and use moisturizer.");
      }
      
      return insights.join(' ') || `Weather conditions in ${cityName} are within normal ranges for this time of year.`;
    }

    // Function to check for weather warnings
    function checkWeatherWarnings(data) {
      const warnings = [];
      
      // Temperature warnings (Fahrenheit)
      if (data.temp <= 14) {  // 14°F = -10°C
        warnings.push({
          title: "Extreme Cold Warning",
          message: "Temperatures are dangerously low. Dress warmly and limit outdoor exposure."
        });
      } else if (data.temp >= 95) {  // 95°F = 35°C
        warnings.push({
          title: "Heat Warning",
          message: "High temperatures detected. Stay hydrated and avoid prolonged sun exposure."
        });
      }
      
      // Wind warnings (mph)
      if (data.wind_speed >= 34) {  // 34 mph ≈ 15 m/s
        warnings.push({
          title: "High Wind Warning",
          message: "Strong winds may affect travel and outdoor activities. Exercise caution."
        });
      }
      
      // Visibility warnings
      if (data.visibility < 1000) {
        warnings.push({
          title: "Low Visibility Warning",
          message: "Poor visibility conditions. Drive carefully and use headlights."
        });
      }
      
      // Storm/severe weather warnings
      const desc = data.description.toLowerCase();
      if (desc.includes('thunderstorm') || desc.includes('storm')) {
        warnings.push({
          title: "Thunderstorm Warning",
          message: "Thunderstorms in the area. Seek shelter and avoid outdoor activities."
        });
      } else if (desc.includes('snow') && data.temp < 0) {
        warnings.push({
          title: "Snow Advisory",
          message: "Snow conditions may affect travel. Drive carefully and allow extra time."
        });
      } else if (desc.includes('fog') || desc.includes('mist')) {
        warnings.push({
          title: "Fog Advisory",
          message: "Reduced visibility due to fog. Use low beam headlights and drive slowly."
        });
      }
      
      return warnings.length > 0 ? warnings[0] : null; // Return first warning
    }

    // Function to show detailed weather information
    async function showWeatherDetails(cityName, lat, lon) {
      const loadingMsg = addLoadingMessage();
      loadingMsg.textContent = `Loading detailed weather data for ${cityName}...`;
      
      try {
        // Get all weather data in parallel
        const [forecastData, historicalData] = await Promise.all([
          getForecastData(cityName),
          getHistoricalWeatherData(cityName)
        ]);
        
        loadingMsg.remove();
        
        const weatherInfoHtml = `
          <div class="weather-info-card">
            <div class="weather-info-header">
              <i class="fas fa-chart-line weather-info-icon"></i>
              <h3 class="weather-info-title">Weather Details - ${cityName}</h3>
            </div>
            <div class="weather-info-sections">
              <div class="weather-info-section">
                <h4><i class="fas fa-clock"></i> 5-Day Forecast</h4>
                <div class="forecast-timeline">
                  ${forecastData.map(day => `
                    <div class="forecast-item">
                      <div class="forecast-time">${day.date}</div>
                      <i class="${getWeatherIcon(day.description)} forecast-icon"></i>
                                             <div class="forecast-temp">${Math.round(day.temp_max)}°F/${Math.round(day.temp_min)}°F<br><small style="opacity: 0.7; font-size: 0.75em;">(${Math.round((day.temp_max - 32) * 5/9)}°C/${Math.round((day.temp_min - 32) * 5/9)}°C)</small></div>
                      <div style="font-size: 0.8rem; opacity: 0.8;">${day.description}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
              
              <div class="weather-info-section">
                <h4><i class="fas fa-history"></i> Historical Data (Last 7 Days)</h4>
                <p>Average temperature trends and patterns for ${cityName}:</p>
                <div class="weather-data-grid">
                  <div class="weather-data-item">
                    <div class="weather-data-label">Avg High</div>
                                         <div class="weather-data-value">${historicalData.avgHigh}°F <small style="opacity: 0.7;">(${Math.round((historicalData.avgHigh - 32) * 5/9)}°C)</small></div>
                  </div>
                  <div class="weather-data-item">
                    <div class="weather-data-label">Avg Low</div>
                                         <div class="weather-data-value">${historicalData.avgLow}°F <small style="opacity: 0.7;">(${Math.round((historicalData.avgLow - 32) * 5/9)}°C)</small></div>
                  </div>
                  <div class="weather-data-item">
                    <div class="weather-data-label">Total Rainfall</div>
                    <div class="weather-data-value">${historicalData.totalRain}mm</div>
                  </div>
                  <div class="weather-data-item">
                    <div class="weather-data-label">Avg Humidity</div>
                    <div class="weather-data-value">${historicalData.avgHumidity}%</div>
                  </div>
                </div>
              </div>
              
              <div class="weather-info-section">
                <h4><i class="fas fa-cloud-rain"></i> Precipitation Map</h4>
                <p>Real-time precipitation radar for the area:</p>
                <iframe class="precipitation-map" 
                  src="https://embed.windy.com/embed2.html?lat=${lat}&lon=${lon}&detailLat=${lat}&detailLon=${lon}&width=650&height=450&zoom=8&level=surface&overlay=rain&product=ecmwf&menu=&message=&marker=&calendar=now&pressure=&type=map&location=coordinates&detail=&metricWind=default&metricTemp=default&radarRange=-1"
                  frameborder="0">
                </iframe>
              </div>
              
              <div class="weather-info-section">
                <h4><i class="fas fa-info-circle"></i> Weather Insights</h4>
                <p>${generateWeatherInsights(cityName, forecastData, historicalData)}</p>
              </div>
            </div>
          </div>
        `;
        
        addMessage(weatherInfoHtml, 'bot', false, true);
        
      } catch (error) {
        loadingMsg.remove();
        addMessage(`Sorry, I couldn't load detailed weather data for ${cityName}. ${error.message}`, 'bot');
      }
    }

    async function handleUserMessage(query) {
      const loadingMsg = addLoadingMessage();
      
      try {
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const city = await extractCityFromQuery(query);
        
        if (!city) {
          loadingMsg.remove();
          addMessage("I couldn't identify a city in your message. Could you please specify which city you'd like weather information for?", 'bot');
          return;
        }

        loadingMsg.textContent = `Looking up weather for ${city}...`;
        
        const weatherData = await getWeatherData(city);
        loadingMsg.remove();
        
        if (weatherData.corrected) {
          const confidence = weatherData.confidence || 0.8;
          const method = weatherData.method || 'fuzzy';
          const originalInput = weatherData.originalInput || city;
          
          // Generate method-specific feedback
          let methodText = "";
          switch (method) {
            case 'exact_correction':
              methodText = "I recognized this common misspelling and";
              break;
            case 'phonetic':
              methodText = "Based on phonetic similarity, I";
              break;
            case 'partial':
              methodText = "I found a partial match and";
              break;
            case 'nlp_fuzzy':
              methodText = confidence > 0.85 ? "Using NLP analysis, I'm confident I" : "Using AI pattern matching, I";
              break;
            default:
              methodText = confidence > 0.9 ? "I'm confident I" : confidence > 0.7 ? "I think I" : "I believe I";
          }
          
          const correctionMessage = `${methodText} corrected "${originalInput}" to "${weatherData.corrected}". Here's the weather:`;
          addMessage(correctionMessage, 'bot');
          addMessage(weatherData, 'bot', true);
        } else {
          addMessage(weatherData, 'bot', true);
        }
        
      } catch (error) {
        loadingMsg.remove();
        addMessage(error.message, 'bot');
      }
    }

    // Event listeners
    inputForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const query = userInput.value.trim();
      if (!query) return;
      
      submitBtn.disabled = true;
      userInput.disabled = true;
      
      addMessage(query, 'user');
      userInput.value = '';
      
      await handleUserMessage(query);
      
      submitBtn.disabled = false;
      userInput.disabled = false;
      userInput.focus();
    });

    userInput.focus();

    document.addEventListener('keydown', (e) => {
      if (!userInput.matches(':focus') && !e.target.matches('input, textarea') && e.key.length === 1) {
        userInput.focus();
      }
    });

    // Initialize everything immediately
    console.log('🚀 Initializing WeatherBot AI...');
    
    // Initialize ticker immediately with loading placeholders
    initializeTicker();
    
    // Start location detection and weather loading in parallel
    Promise.all([
      // Load user's location weather
      initializeLocationWeather(),
      
      // Load live ticker data
      new Promise(resolve => {
        setTimeout(() => {
          loadRealWeatherData().then(resolve);
        }, 1000);
      })
    ]).then(() => {
      console.log('🌟 Weather app fully initialized with location and live data');
    }).catch(error => {
      console.warn('Some initialization features failed:', error);
    });
    
    // Set up automatic data refresh every 15 minutes
    setInterval(() => {
      refreshWeatherData();
    }, 15 * 60 * 1000);
    
    // Also refresh every 5 minutes for more frequent updates
    setInterval(() => {
      refreshWeatherData();
    }, 5 * 60 * 1000);
    
    console.log('🌟 Weather app initialized - loading location and live data...');
  </script>
</body>
</html> 